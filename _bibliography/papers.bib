%% This file is generated by script wriiten by Jiyang

@String{ASE = "International Conference on Automated Software Engineering (ASE)"}
@String{ACL = "Annual Meeting of the Association for Computational Linguistics (ACL)"}
@String{ESECFSE-DEMO = "Joint European Software Engineering Conference and Symposium on the Foundations of Software Engineering (FSE Demonstrations Track)"}
@String{FSE-DEMO = "International Conference on the Foundations of Software Engineering (FSE Demonstrations Track)"}
@String{AST = "International Conference on Automation of Software Test (AST)"}
@String{ICSE-SEIP = "International Conference on Software Engineering (ICSE Software Engineering in Practice Track)"}
@String{ICSE = "International Conference on Software Engineering (ICSE)"}
@String{ISSTA = "International Symposium on Software Testing and Analysis (ISSTA)"}
@String{FSE = "Joint European Software Engineering Conference and Symposium on the Foundations of Software Engineering (FSE)"}
@String{CAP = "Workshop on Computer Assisted Programming (CAP)"}
@String{ICTIR = "International Conference on Theory of Information Retrieval (ICTIR)"}

@inproceedings{ZhongETALTool,
  title     = {1. A Tool for Generating Exceptional Behavior Tests With Large Language Models},
  author    = {Linghan Zhong and Samuel Yuan and Jiyang Zhang and Yu Liu and Pengyu Nie and Li, Junyi Jessy and Gligoric, Milos},
  booktitle = FSE-DEMO,
  year      = {2025},
}


@inproceedings{ZhangETAL24Exlong,
  title     = {2. exLong: Generating Exceptional Behavior Tests with Large Language Models},
  author    = {Jiyang Zhang and Liu, Yu and Pengyu Nie and Li, Junyi Jessy and Gligoric, Milos},
  booktitle = ICSE,
  abstract = {Many popular programming languages, including C#, Java, and Python, support exceptions. Exceptions are thrown during program execution if an unwanted event happens, e.g., a method is invoked with an illegal argument value. Software developers write exceptional behavior tests (EBTs) to check that their code detects unwanted events and throws appropriate exceptions. Prior research studies have shown the importance of EBTs, but those studies also highlighted that developers put most of their efforts on "happy paths", e.g., paths without unwanted events. To help developers fill the gap, we present the first framework, dubbed exLong, that automatically generates EBTs. exLong is a large language model instruction fine-tuned from CodeLlama and embeds reasoning about traces that lead to throw statements, conditional expressions that guard throw statements, and non-exceptional behavior tests that execute similar traces. We compare exLong with the state-of-the-art models for test generation (CAT-LM) and one of the strongest foundation models (GPT-4o), as well as with analysis-based tools for test generation (Randoop and EvoSuite). Our results show that exLong outperforms existing models and tools. Furthermore, we contributed several pull requests to open-source projects and 23 EBTs generated by exLong were already accepted.},
  code =    {https://github.com/EngineeringSoftware/exLong},
  year      = {2025},
  arxiv     = {2405.14619}
}

@inproceedings{ZhangETALDeltaCode,
  title     = {3. Multilingual Code Co-Evolution Using Large Language Models},
  author    = {Jiyang Zhang and Pengyu Nie and Junyi Jessy Li and Milos Gligoric},
  booktitle = FSE,
  year      = {2023},
  pdf       = {papers/DeltaCodeTranslation.pdf},
  slides    = {slides/FSE23.pdf},
  abstract  = {Many software projects implement APIs and algorithms in multiple programming languages. Maintaining such projects is tiresome, as developers have to ensure that any change (e.g., a bug fix or a new feature) is being propagated, timely and without errors, to implementations in other programming languages. In the world of ever-changing software, using rule-based translation tools (i.e., transpilers) or machine learning models for translating code from one language to another provides limited value. Translating each time the entire codebase from one language to another is not the way developers work. In this paper, we target a novel task: translating code changes from one programming language to another using large language models (LLMs). We design and implement the first LLM, dubbed Codeditor, to tackle this task. Codeditor explicitly models code changes as edit sequences and learns to correlate changes across programming languages. To evaluate Codeditor, we collect a corpus of 6,613 aligned code changes from 8 pairs of open-source software projects implementing similar functionalities in two programming languages (Java and C#). Results show that Codeditor outperforms the state-of-the-art approaches by a large margin on all commonly used automatic metrics. Our work also reveals that Codeditor is complementary to the existing generation-based models, and their combination ensures even greater performance.},
  code      = {https://github.com/EngineeringSoftware/codeditor}
}

@inproceedings{ZhangETAL23Using,
  title     = {4. Using Large-scale Heterogeneous Graph Representation Learning for Code Review Recommendations at Microsoft},
  author    = {Jiyang Zhang and Maddila, Chandra and Bairi, Ram and Bird, Christian and Raizada, Ujjwal and Agrawal, Apoorva and Jhawar, Yamini and Herzig, Kim and van Deursen, Arie},
  booktitle = ICSE-SEIP,
  year      = {2023},
  abstract  = {Code review is an integral part of any mature software development process, and identifying the best reviewer for a code change is a well-accepted problem within the software engineering community. Selecting a reviewer who lacks expertise and understanding can slow development or result in more defects. To date, most reviewer recommendation systems rely primarily on historical file change and review information; those who changed or reviewed a file in the past are the best positioned to review in the future. We posit that while these approaches are able to identify and suggest qualified reviewers, they may be blind to reviewers who have the needed expertise and have simply never interacted with the changed files before. Fortunately, at Microsoft, we have a wealth of work artifacts across many repositories that can yield valuable information about our developers. To address the aforementioned problem, we present CORAL, a novel approach to reviewer recommendation that leverages a socio-technical graph built from the rich set of entities (developers, repositories, files, pull requests (PRs), work items, etc.) and their relationships in modern source code management systems. We employ a graph convolutional neural network on this graph and train it on two and a half years of history on 332 repositories within Microsoft. We show that CORAL is able to model the manual history of reviewer selection remarkably well. Further, based on an extensive user study, we demonstrate that this approach identifies relevant and qualified reviewers who traditional reviewer recommenders miss, and that these developers desire to be included in the review process. Finally, we find that "classical" reviewer recommendation systems perform better on smaller (in terms of developers) software projects while CORAL excels on larger projects, suggesting that there is "no one model to rule them all."
               },
  pdf       = {papers/GNNReview.pdf}
}

@inproceedings{ZhangETAL23More,
  title     = {5. More Precise Regression Test Selection via Reasoning about Semantics-Modifying Changes},
  author    = {Liu, Yu and Jiyang Zhang and Nie, Pengyu and Gligoric, Milos and Legunsen, Owolabi},
  booktitle = ISSTA,
  year      = {2023},
  pdf       = {papers/FineRTS.pdf},
  abstract  = {Regression test selection (RTS) speeds up regression testing by only re-running tests that might be affected by code changes. Ideal RTS safely selects all affected tests and precisely selects only affected tests. But, aiming for this ideal is often slower than re-running all tests. So, recent RTS techniques use program analysis to trade precision for speed, i.e., lower regression testing time, or even use machine learning to trade safety for speed. We seek to make recent analysis-based RTS techniques more precise, to further speed up regression testing. Independent studies suggest that these techniques reached a “performance wall” in the speed-ups that they provide. We manually inspect code changes to discover those that do not require re-running tests that are only affected by such changes. We categorize 29 kinds of changes that we find from five projects into 13 findings, 11 of which are semantics-modifying. We enhance two RTS techniques---Ekstazi and STARTS---to reason about our findings. Using 1,150 versions of 23 projects, we evaluate the impact on safety and precision of leveraging such changes. We also evaluate if our findings from a few projects can speed up regression testing in other projects. The results show that our enhancements are effective and they can generalize. On average, they result in selecting 41.7% and 31.8% fewer tests, and take 33.7% and 28.7% less time than Ekstazi and STARTS, respectively, with no loss in safety.},
  slides    = {slides/ISSTA23.pdf},
  code      = {https://github.com/EngineeringSoftware/FineRTS}
}

@inproceedings{ZhangETAL22CoditT5,
  title     = {6. CoditT5: Pretraining for Source Code and Natural Language Editing},
  author    = {Jiyang Zhang and Panthaplackel, Sheena and Nie, Pengyu and Li, Junyi Jessy and Gligoric, Milos},
  booktitle = ASE,
  year      = {2022},
  abstract  = {Pretrained language models have been shown to be effective in many software-related generation tasks; however, they are not well-suited for editing tasks as they are not designed to reason about edits. To address this, we propose a novel pretraining objective which explicitly models edits and use it to build CoditT5, a large language model for software-related editing tasks that is pretrained on large amounts of source code and natural language comments. We fine-tune it on various downstream editing tasks, including comment updating, bug fixing, and automated code review. By outperforming standard generation-based models, we demonstrate the generalizability of our approach and its suitability for editing tasks. We also show how a standard generation model and our edit-based model can complement one another through simple reranking strategies, with which we achieve state-of-the-art performance for the three downstream editing tasks.
               },
  pdf       = {papers/CoditT5.pdf},
  slides    = {slides/ASE22.pdf},
  code      = {https://github.com/EngineeringSoftware/CoditT5}
}

@inproceedings{ZhangETAL22Python,
  title     = {7. Python-by-Contract Dataset},
  author    = {Jiyang Zhang and Ristin, Marko and Phillip, Schanely and Wernher van de Venn, Hans and Gligoric, Milos},
  booktitle = ESECFSE-DEMO,
  year      = {2022},
  pdf       = {papers/PythonContract.pdf},
  abstract  = {Design-by-contract as a programming technique is becoming popular in Python community as various tools have been developed for automatically testing the code based on the contracts. However, there is no sufficiently large and representative Python code base with contracts to evaluate these different testing tools. We present Python-by-contract dataset containing 514 Python functions annotated with contracts using icontract library. We show that our Python-by-contract dataset can be easily used by existing testing tools that take advantage of contracts. The demo video can be found at https://youtu.be/08wZN-xh6mY.},
  code      = {https://github.com/mristin/python-by-contract-corpus},
  video     = {https://www.youtube.com/watch?v=08wZN-xh6mY}
}

@inproceedings{NieETAL22Impact,
  title     = {8. Impact of evaluation methodologies on code summarization},
  author    = {Nie, Pengyu and Jiyang Zhang and Li, Junyi Jessy and Mooney, Raymond and Gligoric, Milos},
  booktitle = ACL,
  year      = {2022},
  abstract  = {There has been a growing interest in developing machine learning (ML) models for code summarization tasks, e.g., comment generation and method naming. Despite substantial increase in the effectiveness of ML models, the evaluation methodologies, i.e., the way people split datasets into training, validation, and test sets, were not well studied. Specifically, no prior work on code summarization considered the timestamps of code and comments during evaluation. This may lead to evaluations that are inconsistent with the intended use cases. In this paper, we introduce the time-segmented evaluation methodology, which is novel to the code summarization research community, and compare it with the mixed-project and cross-project methodologies that have been commonly used. Each methodology can be mapped to some use cases, and the time-segmented methodology should be adopted in the evaluation of ML models for code summarization. To assess the impact of methodologies, we collect a dataset of (code, comment) pairs with timestamps to train and evaluate several recent ML models for code summarization. Our experiments show that different methodologies lead to conflicting evaluation results. We invite the community to expand the set of methodologies used in evaluations.
               },
  pdf       = {papers/NLPEvolv.pdf},
  code      = {https://github.com/EngineeringSoftware/time-segmented-evaluation}
}

@inproceedings{ZhangETAL22Comparing,
  title     = {9. Comparing and Combining Analysis-Based and Learning-Based Regression Test Selection},
  author    = {Jiyang Zhang and Liu, Yu and Gligoric, Milos and Legunsen, Owolabi and Shi, August},
  booktitle = AST,
  year      = {2022},
  pdf       = {papers/MLRTS.pdf},
  abstract  = {Regression testing–rerunning tests on each code version to detect newly–broken functionality-is important and widely practiced. But, regression testing is costly due to the large number of tests and the high frequency of code changes. Regression test selection (RTS) optimizes regression testing by only rerunning a subset of tests that can be affected by changes. Researchers showed that RTS based on program analysis can save substantial testing time for (medium-sized) open-source projects. Practitioners also showed that RTS based on machine learning (ML) works well on very large code repositories, e.g., in Facebook’s monorepository. We combine analysis-based RTS and ML-based RTS by using the latter to choose a subset of tests selected by the former. We first train several novel ML models to learn the impact of code changes on test outcomes using a training dataset that we obtain via mutation analysis. Then, we evaluate the benefits of combining ML models with analysis-based RTS on 10 projects, compared with using each technique alone. Combining ML-based RTS with two analysis-based RTS techniques-Ekstazi and STARTS-selects 25.34% and 21.44% fewer tests, respectively.},
  slides    = {slides/AST22.pdf},
  code      = {https://github.com/EngineeringSoftware/predictiverts}
}

@inproceedings{ZhangETAL20Leveraging,
  title     = {10. Leveraging class hierarchy for code comprehension},
  author    = {Jiyang Zhang and Panthaplackel, Sheena and Nie, Pengyu and Li, Junyi Jessy and Mooney, Raymond J. and Gligoric, Milos},
  booktitle = CAP,
  abstract  = {Descriptive code comments are essential for supporting code comprehension and maintenance. We propose the task of automatically generating comments for overriding methods. We formulate a novel framework which accommodates the unique contextual and linguistic reasoning that is required for performing this task. Our approach features: (1) incorporating context from the class hierarchy; (2) conditioning on learned, latent representations of specificity to generate comments that capture the more specialized behavior of the overriding method; and (3) unlikelihood training to discourage predictions which do not conform to invariant characteristics of the comment corresponding to the overridden method. Our experiments show that the proposed approach is able to generate comments for overriding methods of higher quality compared to prevailing comment generation techniques.},
  year      = {2020},
  pdf       = {papers/HieComment.pdf}
}

@inproceedings{NieETAL19Integrated,
  title     = {11. Integrated Learning of Features and Ranking Function in Information Retrieval},
  author    = {Nie, Yifan and Jiyang Zhang and Nie, Jian-Yun},
  booktitle = ICTIR,
  abstract  = {Recent deep learning models for information retrieval typically aim to learn features either about the contents of the document and the query, or about the interactions between them. However, the existing literature shows that document ranking depends simultaneously on many factors, including both content and interaction features. The integration of both types of neural features has not been extensively studied. In addition, many studies have also shown that the deep neural features cannot replace completely the traditional features, but are complementary. It is thus reasonable to combine deep neural features with traditional features. In this paper, we propose an integrated end-to-end learning framework based on learning-to-rank (L2R) to learn both neural features and the L2R ranking function simultaneously. The framework also has the flexibility to integrate arbitrary traditional features. Our experiments on public datasets confirm that such an integrated learning strategy is better than separate learning of features and ranking function, and integrating traditional features can further improve the results.},
  year      = {2019},
  pdf       = {papers/IR.pdf}
}